<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Will Culpepper's Digital Portfolio</title>
    <link href="css/foundation.min.css" rel="stylesheet">
    <link href="css/app.css" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="images/vessel2_render_final_square.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
            integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
            crossorigin="anonymous" defer>
    </script>
</head>
<body>
<div class="grid-container grid-padding-y">
    <div data-sticky-container>
        <div class="top-bar" data-sticky data-options="marginTop:0;" style="width:100%">
            <div class="top-bar-left">
                <ul class="dropdown menu align-center-middle" data-dropdown-menu>
                    <li class="menu-text"><a href="index.html" style="color:black">Will Culpepper</a></li>
                    <li><a href="contact.html">Contact</a></li>
                    <li><a href="portfolio.html">Portfolio</a></li>
                </ul>
            </div>
        </div>
    </div>
    <div class="top-bar-title">
        <h1 class="text-center">My Work</h1>
    </div>
    <div class="card">
        <div class="card-divider">
            <h2 class="h2">Highlights of my time at Mines</h2>
        </div>
        <div class="card">
            <div class="card-divider">
                <h4>Advanced Software Engineering, Summer 2022</h4>
            </div>
            <div class="card-section">
                <p>This class was my second step into coding in a professional setting. I worked on a team of other CS
                    students to build a web app to replace the Computer Science Department's current auto-grading system
                    for the major's introductory classes (CSCI 200, CSCI 220, CSCI 250, and more).
                    <br><br>
                    The primary motivator behind this project was to rebuild it in a codebase that was more maintainable
                    than the previous version. This web app, dubbed "AutoGrader 5.0," is built on a Flask back-end and a
                    Vue.js front-end. Additionally, the back-end makes queries to a PostgreSQL database used for storing
                    the programming challenges the faculty uses. Furthermore, we were tasked with making the new AutoGrader
                    compatible with a screen reader, as differently-abled students are not able to access the site with
                    the same level of ease as a normally-abled student. The new version of the site is served on a
                    single-page application, and is fully compatible with a screen reader (tested with NVDA).
                    <br><br>
                    This project was tough, in all honesty. Neither I nor any of my teammates had any experience with web
                    programming (you can probably tell, the CSS we used to customize the site is Bootstrap). Nevertheless,
                    we were able to get a product to the client that was both up to their standards and an improvement upon
                    the previous version. I ended the project having acquired skills in HTML, CSS, Javascript, and expanding
                    on my Python skills with both a server implementation and SQL integration.
                </p>
            </div>
            <div class="card-section align-center-middle">
                <img src="images/autograder.png" alt="Field Session AutoGrader" width="600" height="600">
            </div>
        </div>
        <div class="card">
            <div class="card-divider">
                <h4>Software Engineering, Fall 2021</h4>
            </div>
            <div class="card-section">
                <p>This class was my first step into coding in a professional setting. Important things we covered were
                    the Agile software design process and test-driven development, all using Java (and JUnit). Over the
                    course of the semester, my partner and I were able to recreate a version of Clue as a computer game.
                </p>
            </div>
            <div class="card-section align-center-middle">
                <img src="images/clue.png" alt="Clue interface" width="600" height="600">
            </div>
        </div>
    </div>
    <div class="card">
        <div class="card-divider">
            <h4>Computer Graphics, Fall 2021</h4>
        </div>
        <div class="card-section">
            <p>
                This class reignited my passion for computer science, and is the primary focus of what I want to do with
                my degree once I graduate. Here I learned OpenGL and its use in C++, creating graphics almost entirely
                from scratch. I learned shader programming and all the intermediary steps from vertex data to screen
                output (everything from creating the initial vertex buffers to the fragment shader, including tessellation control/evaluation
                and geometry). I learned how to generate Bezier curves and move objects along them. I learned about
                particle systems and collision detection. I learned about lighting models (Gouraud shading, Phong/Blinn-Phong
                illumination) and all kinds of fragment shaders (I even wrote a Cel shader!). Near the end of the semester,
                I even learned the basics of ray tracing. This class was a blast, and is the reason I still code. I made
                a portfolio of the work I did in class throughout the semester, which can be found <a href="graphics.html">here</a>.
            </p>
        </div>
        <div class="card-divider">
            <h4>Other classes I've taken and skills I've acquired while at Mines</h4>
        </div>
        <div class="card-section">
            <h5>Computer Science</h5>
            <ul>
                <li>CSCI 101 - Introduction to CS: to sum it up, we just answered the question, "What is Computer Science?"</li>
                <li>CSCI 102 - Intro to CS Lab: I actually had a job for two semesters as a TA for this class. I taught
                    Python to people who had little-to-no coding experience.</li>
                <li>CSCI 250 - Building a Sensor System: Python-based class that integrated hardware and introductory
                    data science concepts. Acquired and developed skills in Python programming, Linux, Raspberry Pi, and
                    basic data processing (filters, visualization). Also was a TA for this class for two semesters.</li>
                <li>CSCI 262 - Data Structures: learned the basics of modern data structures. Linked lists, stacks, queues,
                    maps, sets, you name it. This class was a particularly tough challenge, since I had never used C++
                    before entering. I came out of it with more than I went in, including a desire to become an electrical
                    engineer. That desire lasted exactly one semester before I realized just how much I like coding.</li>
                <li>CSCI 274 - Introduction to Linux: Here, I learned the basic of Linux (Ubuntu) and the command line.</li>
                <li>CSCI 341 - Computer Organization: Assembly, memory, registers, process optimization. This class was tough, but since I took
                    a digital logic course the semester prior I had a leg up on the course going in.</li>
                <li>CSCI 358 - Discrete Mathematics: logic, proofs, recursion, algorithm analysis, sets, relations,
                    Boolean algebra, trees, and finite-state machines. I had a lot of fun in this class, and it was the
                    easiest non-code-based class to wrap my head around.</li>
                <li>CSCI 400 - Programming Languages: Functional programming, lambda calculus, higher-order functions,
                    syntax, types, and language evaluation. My project group ended up with a very simple JavaScript
                    interpreter by the end of the semester.</li>
                <li>CSCI 403 - Database Management: relational databases, SQL, and data storage. Near the end of the
                    semester we had a project to make assessments from large data sets about homicide rates and housing
                    prices in California.</li>
                <li>CSCI 404 - Artificial Intelligence: </li>
            </ul>
        </div>
        <div class="card-section"><p>You've reached the end of my portfolio, so far. <br>This was a fun little project. I wanted to have something in this website that showed
            that I can work with graphics in a multitude of environments, so I followed
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" target="_blank">Mozilla's tutorial on WebGL.</a>
            The pipeline is pretty much identical to OpenGL, so it was easy to wrap my head around. This cube currently uses
            the Blinn-Phong specular model with Lambertian diffuse all in the fragment shader for smoother lighting. The purple
            shading represents the diffuse, and the yellow represents the specular. Currently, the shader isn't exhibiting
            its expected behavior. But it looks cool!</p></div>
        <div class="card-section">
            <canvas id="glCanvas" width="640" height="480"></canvas>
        </div>
    </div>
</div>
</body>
<script>
    var rotationAngle = 0.0;
    function main(){
        const canvas = document.querySelector("#glCanvas");
        const gl = canvas.getContext("webgl");

        if(gl == null){
            alert("Unable to initialize WebGL app. Your browser might not support it.");
            return;
        }

        const vsSourceGouraud = `
            attribute vec4 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec4 aVertexColor;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            varying highp vec3 diffuseColor;

            void main() {
              gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;

              highp vec3 lightColor = vec3(1.0,1.0,1.0);

              // using directional lighting in this test.
              highp vec3 direction = normalize(vec3(1.0, 1.0, 1.0));

              highp vec4 tNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);

              highp float directionalDiffuse = max(dot(aVertexNormal, direction), 0.0);

              diffuseColor = lightColor*aVertexColor.xyz*directionalDiffuse;
            }
        `;

        const fsSourceGouraud = `
            varying highp vec3 diffuseColor;
            void main() {
              gl_FragColor = vec4(diffuseColor,1.0);
            }
        `;

        const vsSourcePhong = `
            attribute vec4 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec4 aVertexColor;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            varying highp vec3 normal;
            varying highp vec3 fragPos;
            varying highp vec3 vertColor;

            void main(){
                gl_Position = gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                fragPos = vec3(uModelViewMatrix*aVertexPosition);
                normal = normalize(vec3(uNormalMatrix*vec4(abs(aVertexNormal), 1.0)));
                vertColor = aVertexColor.xyz;
            }
        `;

        const fsSourcePhong = `
            precision highp float;
            // using point light for Phong shading.
            highp vec3 lightPos = vec3(1.0,10.0,0.0);
            highp vec3 lightColor = vec3(1.0,1.0,1.0);
            highp vec3 cubeDiffColor = vec3(0.5, 0.25, 1.0);
            highp vec3 cubeAmbColor = cubeDiffColor*0.1;
            highp vec3 cubeSpecColor = vec3(1.0,1.0,0.0);
            highp float cubeShininess = 0.5;
            highp vec3 eyePos = vec3(0.0,0.0,0.0);

            varying highp vec3 normal;
            varying highp vec3 fragPos;
            varying highp vec3 vertColor;

            vec3 diffuse(vec3 fragmentPos, vec3 fragmentNorm){
                vec3 lightVector = -normalize(lightPos - fragmentPos);

                vec3 diffColor = lightColor*cubeDiffColor*max(dot(fragmentNorm, lightVector), 0.0);

                return diffColor;
            }

            vec3 specular(vec3 fragmentPos, vec3 fragmentNorm){
                vec3 lightVector = normalize(lightPos - fragmentPos);

                vec3 viewVector = normalize(eyePos - fragmentPos);
                vec3 halfwayVector = normalize(viewVector + lightVector);

                vec3 specColor = lightColor*cubeSpecColor*pow(max(dot(fragmentNorm, halfwayVector), 0.0), 10.0*cubeShininess);

                return specColor;
            }

            void main(){
                vec3 norm = normal;
                vec3 diff = diffuse(fragPos, norm);
                vec3 spec = specular(fragPos, norm);
                vec3 amb = cubeAmbColor;
                gl_FragColor = vec4(diff + spec + amb, 1.0);
            }

        `;

        const fsSourceCel = `
            precision highp float;
            // using point light for Phong shading.
            highp vec3 lightPos = vec3(5.0,0.0,-5.0);
            highp vec3 lightColor = vec3(1.0,1.0,1.0);
            highp vec3 cubeDiffColor = vec3(0.5, 0.25, 1.0);
            highp vec3 cubeAmbColor = cubeDiffColor*0.1;
            highp vec3 cubeSpecColor = vec3(1.0,1.0,0.0);
            highp float cubeShininess = 0.5;
            highp vec3 eyePos = vec3(0.0,0.0,0.0);

            varying highp vec3 normal;
            varying highp vec3 fragPos;
            varying highp vec3 vertColor;

            vec3 diff_cel(vec3 fragmentPos, vec3 fragmentNorm){
                vec3 intensityFactor;
                vec3 lightVector = -normalize(lightPos - fragmentPos);

                float intensity = dot(lightVector, fragmentNorm);

                if(intensity > 0.95)
                    intensityFactor = vec3(1.0,1.0,1.0);
                else if(intensity > 0.75)
                    intensityFactor = vec3(0.8,0.8,0.8);
                else if(intensity > 0.50)
                    intensityFactor = vec3(0.6,0.6,0.6);
                else if(intensity > 0.25)
                    intensityFactor = vec3(0.4,0.4,0.4);
                else
                    intensityFactor = vec3(0.2,0.2,0.2);

                vec3 diffColor = intensityFactor*lightColor*cubeDiffColor*max(dot(fragmentNorm, lightVector), 0.0);

                return diffColor;
            }

            void main(){
                vec3 norm = normalize(normal);
                vec3 diff = diff_cel(fragPos, norm);
                //vec3 amb = cubeAmbColor;
                gl_FragColor = vec4(diff, 1.0);
            }`

        const shaderProgramGouraud = initShaderProgram(gl, vsSourceGouraud, fsSourceGouraud);
        const shaderProgramPhong = initShaderProgram(gl, vsSourcePhong,  fsSourcePhong);
        const shaderProgramCel = initShaderProgram(gl, vsSourcePhong, fsSourceCel);

        const programInfoGouraud = {
            program: shaderProgramGouraud,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgramGouraud, 'aVertexPosition'),
                vertexColor: gl.getAttribLocation(shaderProgramGouraud, 'aVertexColor'),
                vertexNormal: gl.getAttribLocation(shaderProgramGouraud, 'aVertexNormal'),
            },

            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgramGouraud, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgramGouraud, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgramGouraud, 'uNormalMatrix')
            },
        };

        const programInfoPhong = {
            program: shaderProgramPhong,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgramPhong, 'aVertexPosition'),
                vertexColor: gl.getAttribLocation(shaderProgramPhong, 'aVertexColor'),
                vertexNormal: gl.getAttribLocation(shaderProgramPhong, 'aVertexNormal'),
            },

            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgramPhong, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgramPhong, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgramPhong, 'uNormalMatrix')
            },
        }

        const programInfoCel = {
            program: shaderProgramCel,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgramCel, 'aVertexPosition'),
                vertexColor: gl.getAttribLocation(shaderProgramCel, 'aVertexColor'),
                vertexNormal: gl.getAttribLocation(shaderProgramCel, 'aVertexNormal'),
            },

            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgramCel, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgramCel, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgramCel, 'uNormalMatrix')
            },
        }

        const buffers = initBuffers(gl);

        let then = 0;
        function render(now){
            now *= 0.001;
            const deltaTime = now - then;
            then = now;
            drawScene(gl, programInfoPhong, buffers, deltaTime);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

    }
    function initBuffers(gl){
        const positions = [
            // Front face
            -1.0, -1.0,  1.0,
            1.0, -1.0,  1.0,
            1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
            1.0,  1.0, -1.0,
            1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
            1.0,  1.0,  1.0,
            1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
            1.0, -1.0, -1.0,
            1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
            1.0, -1.0, -1.0,
            1.0,  1.0, -1.0,
            1.0,  1.0,  1.0,
            1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0,
        ];
        const positionBuffer = gl.createBuffer();
        //const posisionData = new Float32Array(positions);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const faceColors = [
            1.0, 1.0, 1.0, 1.0, // white
            1.0, 1.0, 1.0, 1.0, // white
            1.0, 1.0, 1.0, 1.0, // white
            1.0, 1.0, 1.0, 1.0, // white
            1.0, 0.0, 0.0, 1.0, // red
            1.0, 0.0, 0.0, 1.0, // red
            1.0, 0.0, 0.0, 1.0, // red
            1.0, 0.0, 0.0, 1.0, // red
            0.0, 1.0, 0.0, 1.0, // green
            0.0, 1.0, 0.0, 1.0, // green
            0.0, 1.0, 0.0, 1.0, // green
            0.0, 1.0, 0.0, 1.0, // green
            0.0, 0.0, 1.0, 1.0, // blue
            0.0, 0.0, 1.0, 1.0, // blue
            0.0, 0.0, 1.0, 1.0, // blue
            0.0, 0.0, 1.0, 1.0, // blue
            1.0, 1.0, 0.0, 1.0, // yellow
            1.0, 1.0, 0.0, 1.0, // yellow
            1.0, 1.0, 0.0, 1.0, // yellow
            1.0, 1.0, 0.0, 1.0, // yellow
            1.0, 0.0, 1.0, 1.0, // magenta
            1.0, 0.0, 1.0, 1.0, // magenta
            1.0, 0.0, 1.0, 1.0, // magenta
            1.0, 0.0, 1.0, 1.0, // magenta
        ];

        const colors = [];
        for(const c of faceColors){
            colors.push(c, c, c, c);
        }

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(faceColors), gl.STATIC_DRAW);

        const indices = [
            0, 1, 2, 0, 2, 3, // front
            4, 5, 6, 4, 6, 7, // back
            8, 9, 10, 8, 10, 11, // top
            12, 13, 14, 12, 14, 15, // bottom
            16, 17, 18, 16, 18, 19, // right
            20, 21, 22, 20, 22, 23 // left
        ]
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW)

        const vertexNormals = [
            // front
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,

            // back
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,

            // top
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,

            // bottom
            0.0, -1.0, 0.0,
            0.0, -1.0, 0.0,
            0.0, -1.0, 0.0,
            0.0, -1.0, 0.0,

            // right
            1.0, 0.0, 0.0,
            1.0, 0.0, 0.0,
            1.0, 0.0, 0.0,
            1.0, 0.0, 0.0,

            // left
            -1.0, 0.0, 0.0,
            -1.0, 0.0, 0.0,
            -1.0, 0.0, 0.0,
            -1.0, 0.0, 0.0,
        ]

        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);

        return{
            position: positionBuffer,
            color: colorBuffer,
            index_buffer: indexBuffer,
            normals: normalBuffer,
        };
    }

    function drawScene(gl, programInfo, buffers, deltaTime){
        gl.clearColor(0.0,0.0,0.0,1.0);
        gl.clearDepth(1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const fov = 45 * Math.PI/180;
        const aspect = gl.canvas.clientWidth/gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;

        const projMatrix = mat4.create();
        mat4.perspective(projMatrix, fov, aspect, zNear, zFar);

        const mvMatrix = mat4.create();

        //brings the square to the camera's view
        mat4.translate(mvMatrix, mvMatrix, [-0.0,0.0,-6.0]);

        rotationAngle += deltaTime;
        mat4.rotate(mvMatrix, mvMatrix, rotationAngle, [0,0,1]);
        mat4.rotate(mvMatrix, mvMatrix, rotationAngle*0.7, [0,1,0]);
        mat4.rotate(mvMatrix, mvMatrix, rotationAngle*0.1, [1,0,0]);

        const normalMatrix = mat4.create();
        mat4.invert(normalMatrix, mvMatrix);
        mat4.transpose(normalMatrix, normalMatrix);
        //console.log(normalMatrix);

        // binds vertex positions to the shader attribute
        {
            const numComponents = 3;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.vertexAttribPointer(
                programInfo.attribLocations.vertexPosition,
                numComponents,
                type,
                normalize,
                stride,
                offset
            );

            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
        }

        // binds the colors to the shader attribute
        {
            const numComponents = 4;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
            gl.vertexAttribPointer(
                programInfo.attribLocations.vertexColor,
                numComponents,
                type,
                normalize,
                stride,
                offset
            );

            gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);
        }

        {
            const numComponents = 3;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normals);
            gl.vertexAttribPointer(
                programInfo.attribLocations.vertexNormal,
                numComponents,
                type,
                normalize,
                stride,
                offset
            );

            gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);
        }

        // binds indices to the shader for color correspondence to vertices.
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index_buffer)


        gl.useProgram(programInfo.program);

        gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projMatrix);
        gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, mvMatrix);
        gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix);
        {
            const vertexCount = 36;
            const type = gl.UNSIGNED_SHORT;
            const offset = 0;
            gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
        }
    }

    function initShaderProgram(gl, vsSource, fsSource){
        const vShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vShader);
        gl.attachShader(shaderProgram, fShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert(`Unable to initialize the shader program: ${gl.getProgramInfoLog(shaderProgram)}`);
            return null;
        }

        return shaderProgram;
    }

    function loadShader(gl, type, source){
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(`An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`);
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    }







    window.onload = main;
</script>
</html>